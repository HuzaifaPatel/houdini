\section{Motivation}
\label{sec:confinement}

\subsection{The Container Confinement Problem}

Container confinement can be defined as the set of mechanisms and strategies used to isolate a containerized application from the host system and other containers. Effective confinement is critical for maintaining system security and stability, as it ensures that containers operate within defined boundaries by restricting their access to system resources, processes, networks, inter-process communication (IPC), filesystems, devices, and kernel interfaces. 

A challenge with container confinement is that while containers are designed to be isolated from the host and other containers, this isolation is not foolproof. Containers share the same kernel as the host system, meaning any vulnerability in the kernel or container runtime can potentially lead to exploits like container escapes. Unlike VMs, which have strong hardware-level isolation, containers rely on a combination of namespaces, cgroups, Linux capabilities, seccomp, and MAC frameworks to enforce security. However, these mechanisms are complex and prone to misconfigurations and inconsistencies in their enforcement.

The level of confinement of a container is not fixed; it can vary based on the specific requirements or intentions of the user. In other words, the degree to which a container is isolated from the host system or other containers is customizable to meet the user’s needs. The optimal configuration, however, is one that strikes a balance between maximum confinement (restricting access to system resources as much as possible) and functional flexibility (enabling the container to perform its intended tasks). Achieving this balance is the core problem and goal of container confinement. 

\subsection{The Semantic Gap Issue}

There exists a semantic gap in containerized systems, where the intended security policies and the actual behavior of the system don't always align. The semantic gap refers to the difference between what a system is meant to do and how it actually behaves in practice. In other words, it’s the disconnect between the theoretical design of the system and its real-world execution. This gap can occur for various reasons, such as miscommunications, misunderstandings, or limitations in the system's design or configuration.

For example, when setting up a security system, an administrator may want to ensure that containers in a cloud environment are completely isolated from each other and the host system. The goal is to set up strict access controls so that containers cannot interact with each other or the host. However, due to complex settings, misconfigurations, or flaws in how security mechanisms (like namespaces, cgroups, SELinux, etc.) interact, the system might not enforce these isolation policies correctly. As a result, the actual performance may not align with the intended security model.

This gap can happen in many systems, but it is especially common in complex environments like containers, where multiple interdependent components (e.g., the container runtime, kernel features, and security tools) must work together. Misunderstandings or mistakes in configuring these components can lead to unexpected issues or security vulnerabilities, even when the system seems correctly set up. Another factor contributing to the semantic gap is the interaction between different security layers within a containerized system. Security mechanisms such as SELinux, AppArmor, seccomp, cgroups, and network policies must work together without conflicting or creating unintended loopholes. However, in practice, compatibility issues can arise. For instance, some applications require specific capabilities to function, leading administrators to disable security restrictions to get them working, which introduces unintended security risks. Ensuring that different security mechanisms complement rather than contradict each other is essential to closing the semantic gap.


% Since the process of setting up effective container confinement involves balancing maximum isolation with the functional flexibility that allows the container to perform its intended tasks, Houdini provides a mechanism for continuous testing and refinement to reach that balance. In other words, \houdini lets you confine a container by allowing users to iterate and fine-tune the container’s security settings until they achieve an optimal level of confinement.